1.二叉排序树
    二叉排序树又成为二叉查找树,是一种特殊的二叉树。简称BST。
    递归定义:左子树非空,则均小于根结点的值;
            右子树非空,则均大于或大于等于根节点的值;
            左右子树均为二叉排序树.
            
            
2.AVL树
     AVL树又称为平衡二叉排序树。
     In computer science, an AVL tree is a self-balancing binary search tree.是一种自平衡的二叉查找树。所以AVL树是BST树的子集。
     定义:左右子树高度之差小于1；
          左右子树也是AVL树。
     应用:最早的平衡二叉树之一。应用相对其他数据结构比较少。windows 对进程地址空间的管理用到了 AVL 树。
     
     
3.RBT
     RBT:Red BlacK Tree；也是一种二叉排序树，但在每个结点增加一个表示颜色的存储位,其满足一些性质来保证红黑树是基本上平衡的。是一种带颜色的二叉查找树
     AVL是严格平衡树, 因此在增加或者删除节点的时候, 根据不同情况, 旋转的次数比红黑树要多;
     RBT是弱平衡的, 用非严格的平衡来换取增删节点时候旋转次数的降低;
     RBT性质:1>.结点是红色或黑色;
             2>.根节点是黑色；
             3>.叶子结点是黑色;
             4>.每个红色结点的两个子结点都是黑色;保证从叶子结点到根结点红色结点不连续。
             5>.任意结点到叶子结点的路径中黑色结点个数相同。
     关键性质:从根到叶子结点的最长路径不多于最短路径的两倍长,保证了红黑树大致上是平衡的。
     
     应用:Linux下用红黑树管理进程PCB； JAVA中TreeMap的实现；
     
     
4.B树(B-Tree)
     m路查找树:m指的是叉的个数。
     定义:1>.结点最多有m个子树,m-1个关键字.n为关键字的个数,Pi为指向子树根结点的指针,Ki为关键字。1<=i<=i-1;
          2>.Ki<Ki+1;
          3>.子树Pi中所有关键字大于Ki, 小于Ki+1;
          4>.子树P0关键子小于Ki,子树Pn的关键字大于Kn;
          5>.子树Pi也是m路查找树；
     B树:一颗平衡的m路查找树；
     性质:每个结点最多有m棵子树; 根结点至少有两棵子树; 
          除根结点以外的非叶子结点至少有[m/2]棵子树。(向上取整);
          所有叶结点出现在同一层,不含信息成为失败节点.失败结点是虚结点,在B树并不存在.指向其的指针为空指针,只是为了分析B树的查找性能.
          
          
 5.B+树(B+Tree)
      作为B-Tree的变种,比B-Tree多了以下:
          非叶子结点的子树指针与关键字个数相同；
          为所有叶子结点增加一个链指针；
          所有关键字都在叶子结点出现；
      B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree。做这个优化的目的是为了提高区间访问的性能。
          
       应用:用在磁盘文件组织 数据索引和数据库索引。比如mysql大多数存储引擎的索引就是B+Tree；
 
 
 B-Tree与B+Tree区别:
    1.B+Tree一个结点的关键字个数等于其子树的个数; B-Tree子树个数比关键字个数多1;
    2.B+Tree非根结点关键字个数n范围:[m/2] <= n <= m;  B-Tree:[m/2]-1 <= n <= m;
    3.B+Tree非叶子节点仅起到索引的作用；  B-Tree:非叶子结点是有存储数据的;
    4.B+Tree:叶子结点包含全部关键字;   B-Tree:全部关键字 = 叶子结点关键字 + 其他结点的关键字. 因为其不重复。
    
    
