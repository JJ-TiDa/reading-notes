运行时数据区域的划分(抽象的 JVM 的角度)：

  1>.程序计数器:对应OS中的指令计数器来说,保存了下一条需要执行的字节码的指令;
  线程私有内存,不会发生OOM的情况。
  
  2>.JVMStack:java虚拟机栈：方法执行的内存模型,方法执行所需的所有信息在内部开辟栈帧来存储.方法执行的过程队医栈帧在JVM中入栈和出栈的过程。
  线程私有,与线程生命周期相同。
  
  所以就可以解释为什么在JavaWeb的HttpServlet不能像Struts2的Action那样定义一个成员变量去接收页面传递过来的信息.
  HttpServlet是单例且线程不安全的，所以在servlet中接收参数都是在方法内部.如果将参数放在成员变量级别的时候,多个人并发访问会造成线程安全的问题.
  所以HttpServlet则把接受参数放在了方法内部,而在方法内部的时候,方法的生命周期与此时调用的这个线程的生命周期是一致的,并不会发生线程安全问题。
  侧面说明方法的运行是在虚拟机栈,其生命周期与线程相同。
  
  3>.本地方法栈:与java虚拟机栈类似,不过其运行的native方法,而2>运行的是java方法。
  
  4>.java堆:GC堆:存放对象实例, 可以处在物理上不连续,只要逻辑连续的内存空间就可以。
  线程共享的内存区域.Xmx与Xms的设置代表的是其按照可扩展来实现的。
  
  5>.方法区:JVM加载的类信息,产量,静态变量,编译后的代码.同时包括存放各种字面量和符号引用的常量池.
  线程共享的内存区域。
  
  另一种说法是分为：堆（Heap），栈（Stacks），数据段（data segment），代码段（code segment）。是从操作系统上的进程的角度去看的。
  
  具体的还是得R大来说，<a href="https://www.zhihu.com/question/33186690/answer/56347931">JAVA 的内存是如何划分的？</a></br>
  
  GC初步:
    引用计数算法:判断引用计数器的值是否为0来判断对象是否存货,Python中的判断算法就是这种.
    可达性分析算法:GCRoot作为起始点,但一个对象到GCRoot没有任何引用的时候对象则不可用,可回收。
    
    引用分类:
        强引用:new出来的对象,只要强引用存在即不会回收。
        软引用:有用但非必须。电脑里 c 盘满了，这时候我们会清理磁盘，删除对我们来说不是非常重要的东西。
        弱引用:被引用对象只能存活至下一次垃圾回收发生之前.ThreadLocal的中的Entry extends WeakReference<ThreadLocal<?>>。
        虚引用:最弱,目的:垃圾回收后的一个系统通知。
        
    宣告对象死亡:2次可达性算法分析的标记.与finalize方法有关。如果两次标记都没有逃脱,则回收。
